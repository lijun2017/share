<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>promise1</title>
</head>

<body>

</body>
<script>
  //   const p1 = new Promise((resolve, reject) => {
  //     console.log(1)
  //     setTimeout(() => {
  //       // resolve()
  //       console.log(2)
  //     }, 1000)
  //     console.log(3)
  // }).then(() => {
  //   console.log(4)
  // })
  // console.log(5)
  // p1.then(res => console.log(6))

  // 1 3 5 2 4 6

  class MyPromise {
    // 构造方法接收一个回调
    constructor(executor) {
      this._resolveQueue = [] // then收集的执行成功的回调队列
      this._rejectQueue = [] // then收集的执行失败的回调队列

      // 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue
      let _resolve = (val) => {
        // 从成功队列里取出回调依次执行
        while (this._resolveQueue.length) {
          const callback = this._resolveQueue.shift()
          callback(val)
        }
      }
      // 实现同resolve 
      let _reject = (val) => {
        while (this._rejectQueue.length) {
          const callback = this._rejectQueue.shift()
          callback(val)
        }
      }
      // new Promise()时立即执行executor,并传入resolve和reject 
      executor(_resolve, _reject)
    }
    // then方法,接收一个成功的回调和一个失败的回调，并push进对应队列 
    then(resolveFn, rejectFn) {
      this._resolveQueue.push(resolveFn)
      this._rejectQueue.push(rejectFn)
    }
  }

  const p1 = new MyPromise((resolve, reject) => {
    console.log(1)
    setTimeout(() => {
      resolve()
      console.log(2)
    }, 1000)
    console.log(3)
  }).then(() => {
    console.log(4)
  })
  console.log(5)
  p1.then(res => console.log(6))

</script>

</html>